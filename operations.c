
					// CE FICHIER NE CONTIENT QUE LES OPERATIONS DEMANDEES //

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <math.h>
#include <pthread.h>

#define PLAGE 100

typedef struct attribut{
	float* fichier;
	int deb;
	pthread_t th;
	float retour;
	int taille;
}ATTR;

/* Permet de renvoyer le nombre lu sur une ligne dans le fichier
 * fd et à la position indiqués */
float lecture_ligne(int fd, int* position_deb){
	int i = 0, verif;
	float nombre_ligne;
	char* ligne;
	ligne = malloc(sizeof(char)*20);
	
	lseek(fd, *position_deb, SEEK_SET);
	verif = read(fd, ligne, 1);
	//printf("Il lit : %c\n", ligne[i]);
	if(verif == 0){
		printf("Le fichier est vide\n");
		exit(EXIT_FAILURE);
	}
	
	for(i=0; verif != 0 && ligne[i] != '\n' ; i++){
		verif = read(fd, ligne+(i+1), 1);
		(*position_deb)++;
		printf("Nombre : %c\n", ligne[i]);
	}
	printf("deb : %d\n", *position_deb);
	nombre_ligne = atof(ligne);
	free(ligne);
	return nombre_ligne;
}

/* Cette fonction permet de renvoyer le minimum */
void* min(void* th){
	int i;
	printf("es tu la\n");
	ATTR* t = (ATTR*) th;
	float min = t->fichier[t->deb];
	printf("numero : %d\n", t->th);
	for(i = 1; t->deb+i < t->taille && i<PLAGE; i++){
		if(min > t->fichier[t->deb+i]){
			printf("reponse : %f\n", t->retour);
			//printf("position : %d\n", position_deb);
			min = t->fichier[t->deb+i];
		}
	}
	t->retour = min;
	return NULL;
}


//UN PROCESSUS CHEF

float chef(void* code, char* nom_fichier){
	
			/// Déclarations des variables ///
	int fd;
	int i, position_deb = 0;
	float nombre;
	int tot, n, deb = 0;
	ATTR* thread;
	float* fichier;
	printf("fichier : %s\n", nom_fichier);
	//printf("code : %s\n", code);
	
			/// Initialisations ///
	fd = open(nom_fichier, O_RDONLY);
	nombre = lecture_ligne(fd, &position_deb);
	if(nombre == 0 || nombre == -1) exit(EXIT_FAILURE);
	tot = (int) nombre;
	n = tot/PLAGE;
	if(fmod(tot, PLAGE) != 0) n++;
	printf("tot : %d, n : %d\n", tot, n);
	fichier = malloc(sizeof(float)*tot);
	thread = malloc(sizeof(ATTR)*n);
	
			/// Remplissage du tableau avec les valeurs contenues dans le fichier ///
	position_deb += 1;
	for(i = 0; i<tot; i++){
		fichier[i] = lecture_ligne(fd, &position_deb);
		printf("Case %d : %f\n", i,fichier[i]);
		position_deb = position_deb +1; //à cause du \n
	}

	for(i=0; i<tot; i++){
		printf("%f ", fichier[i]);
	}
	printf(" ");
	
			/// Initialisation et création des threads ///

	for(i=0; i<n; i++, deb = deb+PLAGE){
		printf("avant initialisation\n");
		thread[i].deb = deb;
		thread[i].fichier = fichier;
		thread[i].th = i;
		printf("voici mon numero : %d\n", thread[i].th);
		thread[i].taille = tot;
		thread[i].retour = 0.1;
		pthread_create(&thread[i].th, NULL, code, &thread[i]);
	}
	
			/// Obtention des réponses ///
	float* retour;
	retour = malloc(sizeof(float)*n);
	printf("j'attend le thread\n");
	for(i=0; i<n; i++){
		printf("numero du thread : %d\n", thread[i].th);
		pthread_join(thread[i].th, NULL);
		retour[i] = thread[i].retour;
		//printf("retour : %f\n", retour[i]);
	}
	
			/// Recherche de la réponse finale ///
	
	if(n == 1){
		close(fd);
		free(thread);
		free(fichier);
		return thread[0].retour;
	}

	ATTR reponse;
	reponse.fichier = retour;
	reponse.deb = 0;
	reponse.taille = n;
	pthread_create(&reponse.th, NULL, code, &reponse);
	pthread_join(reponse.th, NULL);
	
	close(fd);
	free(thread);
	free(fichier);
	
	return reponse.retour;
}

float min_tab(int n, float tab[n]){
	int i;
	float min = tab[0];
	
	for(i=1; i<n; i++){
		if(min > tab[i]) {
			min = tab[i];
		}
	}
	return min;
}

float processus_directeur(void* code, int nb_fichiers, char** fichiers){
	
				/// Déclaration des varibales ///
	int i, pid;
	float retour; // pour récupérer un résultat d'un processus chef
	float* retour_chef; // pour stocker tous les résultats des processus chefs
	retour_chef = malloc(sizeof(float)*nb_fichiers);
	//printf("retour: %d\n", retour_chef[0]); -> retourne un chiffre aléatoire du style 36545132
	int tab[2];
	pipe(tab); // création d'un tube pour faire passer les retours des processus chefs au directeur
	char* buf; // pour stocker le résultat d'un processus chef
	buf = malloc(sizeof(char)*nb_fichiers);
	pthread_mutex_t m;
	pthread_mutex_init(&m, NULL); // création d'un mutex puisque tous les processus vont écrire dans le tube
	printf("nb_fichier : %d\n", nb_fichiers);
	
				/// Création des processus chef ///
	
	for(i=0; i<nb_fichiers; i++){
		pid = fork(); // on créé un processus
		printf("i : %d\n", i);
		if(pid == 0){ // le processus fils exécute son code
			retour = chef(code, fichiers[i+1]); 
			printf("retour apres chef : %f\n", retour);
			sprintf(buf, "%f", retour); //on convertit le float renvoyé en chaine de caractères
			printf("dans buf : %c\n", buf[0]);
			pthread_mutex_lock(&m);
			close(tab[0]);
			write(tab[1], buf, 1);
			printf("dans le tube: %d\n", tab[1]);
			close(tab[1]);
			pthread_mutex_unlock(&m); //on l'écrit dans le tube
			exit(0); //on termine le processus
		}
		
		else { //le processus père
			close(tab[1]);
			read(tab[0], retour_chef, 1); //on lit le tube et on stocke les résultats dans un tableau appelé "retour-chef"
			printf("dans le tube: %d\n", tab[0]);
			printf("retour chef: %f\n", retour_chef[0]);
			close(tab[0]);
			wait(NULL);
		}
	}

				/// Récupération des résultats ///

	/*for(i=0; i<nb_fichiers; i++){//ici dans le processus directeur
		close(tab[1]);
		read(tab[0], retour_chef, 1); //on lit le tube et on stocke les résultats dans un tableau appelé "retour-chef"
		//printf("retour: %d\n", retour_chef[i]); -> retourne le même chiffre que le printf du début
		//close(tab[0]);
		wait(NULL);
	}*/
	
	free(buf);

	return min_tab(nb_fichiers, retour_chef);
	
}

int main(int argc, char** argv){
	
	float res = 0.0;
	res = processus_directeur(min, 1, argv);
	printf("res : %f\n", res);
	
	
	return 0;
}

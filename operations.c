
					// CE FICHIER NE CONTIENT QUE LES OPERATIONS DEMANDEES //

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <math.h>
#include <pthread.h>

#define PLAGE 100

typedef struct attribut{
	float** fichier;
	int deb;
	pthread_t th;
	float retour;
}ATTR;

/* Permet de renvoyer le nombre lu sur une ligne dans le fichier
 * fd et à la position indiqués */
float lecture_ligne(int fd, int* position_deb){
	int i = 0, verif;
	float nombre_ligne;
	char* ligne;
	ligne = malloc(sizeof(char)*20);
	
	lseek(fd, *position_deb, SEEK_CUR);
	verif = read(fd, ligne, 1);
	printf("Il lit : %c\n", ligne[i]);
	if(verif == 0){
		return -1;
	}
	
	for(i=0; ligne[i] != '\n' && verif != 0; i++){
		verif = read(fd, ligne+(i+1), 1);
		(*position_deb)++;
		printf("Nombre : %c\n", ligne[i]);
	}
	
	nombre_ligne = atof(ligne);
	printf("Du coup : %f\n", nombre_ligne);
	free(ligne);
	return nombre_ligne;
}


//UN PROCESSUS CHEF

float chef(void* code, char* nom_fichier){
	int fd;
	int i, position_deb = 0;
	float nombre;
	int tot, n, deb = 0;
	
	fd = open(nom_fichier, O_RDONLY);
	nombre = lecture_ligne(fd, &position_deb);
	if(nombre == 0 || nombre == -1) exit(EXIT_FAILURE);
	tot = (int) nombre;
	n = tot/100;
	if(fmod(n, 100) != 0) n++;
	ATTR thread[n];
	float* fichier;
	fichier = malloc(sizeof(float)*tot);
	
	for(i=0; i<n; i++, deb = deb+100){
		thread[i].deb = deb;
		*(thread[i].fichier) = fichier;
		thread[i].th = i;
	}
	
	position_deb += 1;
	for(i = 0; i<tot; i++){
		fichier[i] = lecture_ligne(fd, &position_deb);
		position_deb = position_deb +1; //à cause du \n
	}

	for(i=0; i<n; i++){
		pthread_create(&thread[i].th, NULL, code, &thread[i]);
	}
	float retour[n];
	for(i=0; i<n; i++){
		pthread_join(thread[i].th, NULL);
		retour[i] = thread[i].retour;
	}
	
	ATTR reponse;
	*(reponse.fichier) = retour;
	reponse.deb = 0;
	pthread_create(&reponse.th, NULL, code, &reponse);
	pthread_join(reponse.th, NULL);
	close(fd);
	
	return reponse.retour;
}


//UN PROCESSUS CHEF

/* Cette fonction permet de renvoyer le minimum */

void* min(void* th){
	int i;
	ATTR* t = (ATTR*) th;
	float min = *(t->fichier[t->deb]);
	printf("min :%f\n", min);
	for(i = 1; i<7  && t->fichier[i] != NULL; i++){
		if(min > *(t->fichier[t->deb+i])){
			//printf("position : %d\n", position_deb);
			min = *(t->fichier[t->deb+i]);
		}
	}
	t->retour = min;
	return NULL;

}

/* Cette fonction permet de renvoyer le maximum 
float max(char* nom_fichier, int position_deb, int plage){
	int fd, i;
	float max, tmp;
	
	fd = open(nom_fichier, O_RDONLY);
	max = lecture_ligne(fd, &position_deb);
	if(max == -1) return -1;
	position_deb = position_deb +2; //à cause du \n
	for(i = 1; i<plage; i++){
		tmp = lecture_ligne(fd, &position_deb);
		if(max < tmp){
			printf("position : %d\n", position_deb);
			max = tmp;
		}
		position_deb = position_deb +2; //à cause du \n
	}
	close(fd);
	return max;
}

 Cette fonction permet de renvoyer la moyenne des valeurs présentes dans un fichier 
float avg(char* nom_fichier, int position_deb, int plage){
	int fd, i;
	float somme;
	
	fd = open(nom_fichier, O_RDONLY);
	somme = lecture_ligne(fd, &position_deb);
	if(somme == -1) return -1;
	position_deb = position_deb +2; //à cause du \n
	for(i = 1; i<plage; i++){
		somme = somme + lecture_ligne(fd, &position_deb);
		printf("position : %d\n", position_deb);
		position_deb = position_deb +2; //à cause du \n
	}
	plage = plage*1.0;
	somme = somme/plage;
	close(fd);
	return somme;
}

 Cette fonction permet de renvoyer la somme des valeurs présentes dans un fichier 
float sum(char* nom_fichier, int position_deb, int plage){
	int fd, i;
	float somme;
	
	fd = open(nom_fichier, O_RDONLY);
	somme = lecture_ligne(fd, &position_deb);
	if(somme == -1) return -1;
	position_deb = position_deb +2; //à cause du \n
	for(i = 1; i<plage; i++){
		somme = somme + lecture_ligne(fd, &position_deb);
		printf("position : %d\n", position_deb);
		position_deb = position_deb +2; //à cause du \n
	}

	close(fd);
	return somme;
}

 Cette fonction permet de renvoyer le nombre de valeurs impaires présentes dans un fichier 
float odd(char* nom_fichier, int position_deb, int plage){
	int fd, i;
	float impair = 0.0;
	
	fd = open(nom_fichier, O_RDONLY);
	if(fmod(lecture_ligne(fd, &position_deb), 2.0)== 1.0) impair++;
	if(impair == -1) return -1;
	position_deb = position_deb +2; //à cause du \n
	for(i = 1; i<plage; i++){
		if(fmod(lecture_ligne(fd, &position_deb), 2.0)== 1.0){
			impair++;
			printf("position : %d\n", position_deb);
		}
		position_deb = position_deb +2; //à cause du \n
	}

	close(fd);
	return impair;
}
*/

 /*Cette fonction permet de renvoyer le nombre de valeurs impaires présentes dans un fichier 
float odd(char* nom_fichier, int position_deb, int plage){
	int fd, i;
	float impair = 0.0;
	
	fd = open(nom_fichier, O_RDONLY);
	if(fmod(lecture_ligne(fd, &position_deb), 2.0)== 1.0) impair++;
	if(impair == -1) return -1;
	position_deb = position_deb +2; //à cause du \n
	for(i = 1; i<plage; i++){
		if(fmod(lecture_ligne(fd, &position_deb), 2.0)== 1.0){
			impair++;
			printf("position : %d\n", position_deb);
		}
		position_deb = position_deb +2; //à cause du \n
	}

	close(fd);
	return impair;
}
*/

int main(int argc, char** argv){
	
	float res;
	res = chef(min, "lol.txt");
	
	
	return 0;
}

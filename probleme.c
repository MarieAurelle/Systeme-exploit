float processus_directeur(char* code, int nb_fichiers, char** fichiers){
	
				/// Déclaration des varibales ///
	int i, pid;
	float retour; // pour récupérer un résultat d'un processus chef
	float* retour_chef; // pour stocker tous les résultats des processus chefs
	retour_chef = malloc(sizeof(float)*nb_fichiers);
	//printf("retour: %d\n", retour_chef[0]); -> retourne un chiffre aléatoire du style 36545132
	int tab[2];
	pipe(tab); // création d'un tube pour faire passer les retours des processus chefs au directeur
	char* buf; // pour stocker le résultat d'un processus chef
	buf = malloc(sizeof(char)*nb_fichiers);
	pthread_mutex_t m;
	pthread_mutex_init(&m, NULL); // création d'un mutex puisque tous les processus vont écrire dans le tube
	
				/// Création des processus chef ///
	
	for(i=0; i<nb_fichiers; i++){
		pid = fork(); // on créé un processus
		
		if(pid == 0){ // le processus exécute son code
			retour = chef(code, fichiers[i+1]); 
			sprintf(buf, "%f", retour); //on convertit le float renvoyé en chaine de caractères
			pthread_mutex_lock(&m);
			close(tab[0]);
			write(tab[1], buf, 1);
			close(tab[1]);
			pthread_mutex_unlock(&m); //on l'écrit dans le tube
			exit(0); //on termine le processus
		} 
	}

				/// Récupération des résultats ///

	for(i=0; i<nb_fichiers; i++){//ici dans le processus directeur
		close(tab[1]);
		read(tab[0], retour_chef, 1); //on lit le tube et on stocke les résultats dans un tableau appelé "retour-chef"
		//printf("retour: %d\n", retour_chef[i]); -> retourne le même chiffre que le printf du début
		close(tab[0]);
		wait(NULL);
	}
	
	free(buf);
	free(retour_chef);
	return min_tab(nb_fichiers, retour_chef);
	
}

#include "process_directeur.h"

					// CE FICHIER CONTIENT LE PROGRAMME DU PROCESSUS DIRECTEUR //

/*Cette fonction permet de choisir la fonction à exécuter après retour des résultats 
 * des processus chef 
 * code -> l'opération à effectuer
 * nb_fichiers -> le nombre de fichiers 
 * retour_chef -> le tableau contenant les résultats des processus chef
 * elle renvoie le résultat final sur tous les fichiers*/
float choix(void* code, int nb_fichiers, float* retour_chef){

	if(code == max){
		return max_tab(nb_fichiers, retour_chef);
	}
	if(code == min){
		return min_tab(nb_fichiers, retour_chef);
	}
	if(code == avg){
		return avg_tab(nb_fichiers, retour_chef);
	}
	if(code == sum){
		return sum_tab(nb_fichiers, retour_chef);
	}
	if(code == odd){
		return odd_tab(nb_fichiers, retour_chef);
	}
	else{
		printf("probleme de code\n");
		exit(EXIT_FAILURE);
	}
}

/*Cette fonction effectue le travail du processus directeur
 * elle prend en paramètre l'opération à effectuer, le nombre de fichiers à lire, les noms des fichiers
 * elle renvoie le résultat final sur tous les fichiers*/
float processus_directeur(void* fonction, int nb_fichiers, char** noms_fichiers){
	
			/// Déclarations des variables ///
	/* retour -> permet de récupérer la valeur de retour d'un chef (donc d'un processus fils), retour_chef -> tableau
	 * qui permet de stocker les retours des processus fils afin de permettre au processus père d'effectuer un dernier
	 * traitement dessus */
	int i, pid, status, n;
	float retour;
	float* retour_chef;
	
	int tab[2];
	pipe(tab);
	char buf[1024];
	
	pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
	
	
			/// Initialisation ///
	retour_chef = malloc(sizeof(float)*nb_fichiers);

			/// Création des processus chefs ///
	
	for(i=0; i<nb_fichiers; i++){ //pour chaque fichier on créé un processus chef
		pid = fork();
		if(pid == 0){ //quand on est dans le processus fils, on lance la fonction chef sur un fichier donné
			retour = chef(fonction, noms_fichiers[i]); //ici on récupère le retour du processus fils
			printf("retour : %f\n", retour);
			pthread_mutex_lock(&m);
			close(tab[0]);
			
			sprintf(buf, "%f", retour);
			write(tab[1], buf, 1024);
			printf("tab[1] : %f\n", tab[1]);
			close(tab[1]);
			pthread_mutex_unlock(&m);
			
			exit(retour); //on ferme le processus
		} else { //dans le père on attend la fin de l'exécution des processus fils puis on stocke le retour dans un tableau
			waitpid(pid, NULL, 0);
			char ret[1024];
			close(tab[1]);
			n = read(tab[0], ret, 1024);
			tab[0] == NULL;
			if( n > 0) retour_chef[i] = atof(ret);
			else printf("erreur\n");
			printf("ret : %s\n", ret);		
			/*if(WIFEXITED(status)){ //si le processus fils a bien été arrêté alors...
				retour_chef[i] = WEXITSTATUS(status); //...on stocke sa valeur de retour dans un tableau
			} else {
				printf("ERROR\n");
			}*/
		}
	}
	close(tab[0]);
	pthread_mutex_destroy(&m);
			/// Dernier traitement pour trouver le résultat final ///
	int res_final = choix(fonction, nb_fichiers, retour_chef);
	free(retour_chef);

	return res_final;
}



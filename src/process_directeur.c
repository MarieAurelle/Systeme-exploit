#include "process_directeur.h"

					// CE FICHIER CONTIENT LE PROGRAMME DU PROCESSUS DIRECTEUR //

/*Cette fonction permet de choisir la fonction à exécuter après retour des résultats 
 * des processus chef 
 * code -> l'opération à effectuer
 * nb_fichiers -> le nombre de fichiers 
 * retour_chef -> le tableau contenant les résultats des processus chef
 * elle renvoie le résultat final sur tous les fichiers*/
float choix(void* code, int nb_fichiers, float* retour_chef){

	if(code == max){
		return max_tab(nb_fichiers, retour_chef);
	}
	if(code == min){
		return min_tab(nb_fichiers, retour_chef);
	}
	if(code == avg){
		return avg_tab(nb_fichiers, retour_chef);
	}
	if(code == sum){
		return sum_tab(nb_fichiers, retour_chef);
	}
	if(code == odd){
		return odd_tab(nb_fichiers, retour_chef);
	}
	else{
		printf("probleme de code\n");
		exit(EXIT_FAILURE);
	}
}

/*Cette fonction effectue le travail du processus directeur
 * elle prend en paramètre l'opération à effectuer, le nombre de fichiers à lire, les noms des fichiers
 * elle renvoie le résultat final sur tous les fichiers*/
float processus_directeur(void* fonction, char** noms_fichiers){
	
			/// Déclarations des variables ///
	/* retour -> permet de récupérer la valeur de retour d'un chef (donc d'un processus fils), retour_chef -> tableau
	 * qui permet de stocker les retours des processus fils afin de permettre au processus père d'effectuer un dernier
	 * traitement dessus */
	int i=0, pid, n;
	float retour;
	float* retour_chef;
	int nb_fichiers = 0;
	
	/*Création du tube*/
	int tab[2];
	pipe(tab);
	
	char buf[1024];
	
	/*Création et initialisation du mutex*/ 
	pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

			/// Initialisation ///
	retour_chef = malloc(sizeof(float)*20);

			/// Création des processus chefs ///
	while(noms_fichiers[i+2] != '0'){ //pour chaque fichier on créé un processus chef
		nb_fichiers++;
		pid = fork();
		if(pid == 0){ //quand on est dans le processus fils, on lance la fonction chef sur un fichier donné
			retour = chef(fonction, noms_fichiers[i+2]); //ici on récupère le retour du processus fils
			/*on verrouille le tube pour que seul un processus fils puisse écrire dedans
			 *et on écrit le retour dans le tube*/
			pthread_mutex_lock(&m);
			close(tab[0]);
			
			sprintf(buf, "%f", retour); // conversion float vers chaîne de caractère
			write(tab[1], buf, 1024);

			close(tab[1]);
			pthread_mutex_unlock(&m);
			
			exit(0); //on ferme le processus
		} else { //dans le père on attend la fin de l'exécution des processus fils 
			wait(NULL);
		}
	}
	
	/*le processus père lit les valeurs du tube et les stocke dans un tableau*/
	char ret[1024];
	close(tab[1]);
	i = 0;
	while((n = read(tab[0], ret, 1024)) > 0) {
		retour_chef[i] = atof(ret);
		i++;
	}
	
	close(tab[0]);
	pthread_mutex_destroy(&m);
	
			/// Dernier traitement pour trouver le résultat final ///
	float res_final = choix(fonction, nb_fichiers, retour_chef);
	free(retour_chef);

	return res_final;
}



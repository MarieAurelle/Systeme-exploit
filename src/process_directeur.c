#include "process_directeur.h"

					// CE FICHIER CONTIENT LE PROGRAMME DU PROCESSUS DIRECTEUR //

/*Cette fonction permet de choisir la fonction à exécuter après retour des résultats 
 * des processus chef en fonction du code*/
float choix(void* code, int nb_fichiers, float* retour_chef){
	if(strcmp(code, "min") == 0){
		return min_tab(nb_fichiers, retour_chef);
	}
	if(strcmp(code, "max") == 0){
		return max_tab(nb_fichiers, retour_chef);
	}
	if(strcmp(code, "avg") == 0){
		return avg_tab(nb_fichiers, retour_chef);
	}
	if(strcmp(code, "sum") == 0){
		return sum_tab(nb_fichiers, retour_chef);
	}
	if(strcmp(code, "odd") == 0){
		return odd_tab(nb_fichiers, retour_chef);
	}
	else{
		printf("probleme de code\n");
		exit(EXIT_FAILURE);
	}
}

float processus_directeur(void* code, int nb_fichiers, char** fichiers){
	
			/// Déclarations des variables ///
	/* retour -> permet de récupérer la valeur de retour d'un chef (donc d'un processus fils), retour_chef -> tableau
	 * qui permet de stocker les retours des processus fils afin de permettre au processus père d'effectuer un dernier
	 * traitement dessus */
	int i, pid, status;
	float retour;
	float* retour_chef;
	char* fonction;
	fonction = (char*) code;
	
			/// Initialisation ///
	retour_chef = malloc(sizeof(float)*nb_fichiers);

			/// Création des processus chefs ///
	
	for(i=0; i<nb_fichiers; i++){ //pour chaque fichier on créé un processus chef
		pid = fork();
		if(pid == 0){ //quand on est dans le processus fils, on lance la fonction chef sur un fichier donné
			retour = chef(code, fichiers[i]);
			printf("retour : %f\n", retour);
			exit(retour);
		} else { //dans le père on attend la fin de l'éxecution des processus fils puis on stocke le retour dans un tableau
			wait(&status);
			if(WIFEXITED(status)){
				retour_chef[i] = WEXITSTATUS(status);
			} else {
				printf("ERROR\n");
			}
		}
	}
			/// Dernier traitement pour trouver le résultat final ///
	int res_final = choix(fonction, nb_fichiers, retour_chef);
	free(retour_chef);

	return res_final;
}



#include "auxiliaires.h"
					// CE FICHIER CONTIENT LE PROGRAMME DES PROCESSUS CHEFS //

float chef(void* code, char* nom_fichier){
	
			/// Déclarations des variables ///
	/*fd -> fichier, positions_deb -> pour lire les lignes du fichier, total_lignes -> première ligne du fichier,
	 * nb_thread -> nombre de thread que le processus doit créer, deb -> début du traitement par un thread sur le tableau */
	int fd, position_deb, total_lignes, nb_thread, deb;
	float nombre; // retour de la fonction lecture avant conversion en total_lignes
	ATTR* thread; //un thread
	float* fichier; //un tableau contenant toutes les valeurs du fichier
	float* retour; //un tableau qui va contenir tous les retour des différents threads
	int i;
	
			/// Initialisations ///
	fd = open(nom_fichier, O_RDONLY); // ouverture du fichier
	position_deb = 0;
	deb = 0;
	nombre = lecture_ligne(fd, &position_deb);
	if(nombre == 0 || nombre == -1) exit(EXIT_FAILURE); // si si nombre = -1 alors il n'y à rien à lire, le fichier est vide
	total_lignes = (int) nombre;									// si nombre = 0 alors il n'y a aucune valeur dans le fichier
	nb_thread = total_lignes/PLAGE; // calcul du nombre de thread par rapport au nombre d'éléments qu'un thread peut traiter
	if(fmod(total_lignes, PLAGE) != 0) nb_thread++; //vérification qu'il ne reste pas des valeurs à traiter, si oui on rajoute un thread
	fichier = malloc(sizeof(float)*total_lignes);
	retour = malloc(sizeof(float)*nb_thread);
	thread = malloc(sizeof(ATTR)*nb_thread);
	
			/// Remplissage du tableau avec les valeurs contenues dans le fichier ///
	position_deb += 1; //pour ne pas lire la première ligne du fichier
	for(i = 0; i<total_lignes; i++){
		fichier[i] = lecture_ligne(fd, &position_deb);
		position_deb = position_deb +1; //à cause du \n
	}
	
			/// Initialisation et création des threads ///

	for(i=0; i<nb_thread; i++, deb = deb+PLAGE){
		thread[i].deb = deb; //chaque thread va commencer le traitement de 100 en 100
		thread[i].fichier = fichier; //chaque thread va pointer sur le tableau fichier afin d'avoir accès aux données
		thread[i].th = i;
		thread[i].taille = total_lignes; //permet de dire au thread quelle longueur il ne doit pas dépasser
		pthread_create(&thread[i].th, NULL, code, &thread[i]);
	}
	
			/// Obtention des réponses ///
	/* Ici on remplit le tableau retour avec les retour des threads */
	for(i=0; i<nb_thread; i++){
		pthread_join(thread[i].th, NULL);
		retour[i] = thread[i].retour;
	}
	
			/// Recherche de la réponse finale ///
	if(nb_thread == 1){ //s'il n'y a qu'un seul thread, on peut renvoyer tout de suite la réponse
		close(fd);
		free(thread);
		free(fichier);
		free(retour);
		return thread[0].retour;
	}

	/* S'il y a plusieurs thread, on créer un dernier thread qui va s'occuper d'effectuer une dernière fois
	 * l'opération demander mais sur l'ensemble des réponses données par les threads, soit sur le tableau retour */
	ATTR reponse;
	reponse.fichier = retour; //il pointe sur le tableau retour
	reponse.deb = 0;
	reponse.taille = nb_thread;
	pthread_create(&reponse.th, NULL, code, &reponse);
	pthread_join(reponse.th, NULL);
	
	close(fd);
	free(thread);
	free(fichier);
	free(retour);
	
	return reponse.retour;
}

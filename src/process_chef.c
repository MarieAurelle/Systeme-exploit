#include "process_chef.h"

					// CE FICHIER CONTIENT LE PROGRAMME DES PROCESSUS CHEFS //

/*Cette fonction permet de remplir le tableau fichier avec les valeurs contenues dans le fichier qu'on est en
 * train de lire. 
 * fd -> descripteur du fichier
 * total_lignes -> nombre de lignes que le fichier doit contenir
 * position_deb -> position de départ dans le fichier (à la deuxième ligne) */
void remplissage_tableau(float* fichier, int fd, int total_lignes, int *position_deb){
	int i;
	(*position_deb) += 1; //pour ne pas lire la première ligne du fichier
	for(i = 0; i<total_lignes; i++){
		fichier[i] = lecture_ligne(fd, position_deb);
		printf("case : %f\n", fichier[i]);
		(*position_deb) = (*position_deb) +1; 
	}
}

/*Cette fonction intialise les champs de la structure des threads et les crée*/
void init_creation_threads(ATTR* thread, float* fichier, int nb_thread, int total_lignes, void* fonction){
	int i;
	for(i=0; i<nb_thread; i++){
		thread[i].deb = i*PLAGE; //chaque thread va commencer le traitement de 100 en 100
		thread[i].fichier = fichier; //chaque thread va pointer sur le tableau fichier afin d'avoir accès aux données
		thread[i].th = i;
		thread[i].taille = total_lignes; //permet de dire au thread quelle longueur il ne doit pas dépasser
		pthread_create(&thread[i].th, NULL, fonction, &thread[i]);
	}
}

/* Cette fonction effectue à l'aide d'un autre thread l'opération demandée dans le tableau retour*/
float reponse(float* retour, void* fonction, int nb_thread){
	ATTR reponse;
	reponse.fichier = retour; //il pointe sur le tableau retour
	reponse.deb = 0;
	reponse.taille = nb_thread;
	pthread_create(&reponse.th, NULL, fonction, &reponse);
	pthread_join(reponse.th, NULL);
	return reponse.retour;
}

float chef(void* fonction, char* nom_fichier){
	
			/// Déclarations des variables ///
	/*fd -> fichier, positions_deb -> pour lire les lignes du fichier, total_lignes -> première ligne du fichier,
	 * nb_thread -> nombre de thread que le processus doit créer*/
	int fd, position_deb, total_lignes, nb_thread;
	float nombre; // retour de la fonction lecture avant conversion en total_lignes
	ATTR* thread; //un thread
	float* fichier; //un tableau contenant toutes les valeurs du fichier
	float* retour; //un tableau qui va contenir tous les retour des différents threads
	int i;
	
			/// Initialisations ///
	//printf("nom fichier : %s\n", nom_fichier);
	fd = open(nom_fichier, O_RDONLY); // ouverture du fichier
	if(fd == -1){
		printf("fichier pas ouvert\n");
	}
	position_deb = 0;
	nombre = lecture_ligne(fd, &position_deb);
	if(nombre == 0 || nombre == -1) exit(EXIT_FAILURE); // si si nombre = -1 alors il n'y à rien à lire, le fichier est vide
														// si nombre = 0 alors il n'y a aucune valeur dans le fichier
	total_lignes = (int) nombre;									
	nb_thread = total_lignes/PLAGE; // calcul du nombre de threads par rapport au nombre d'éléments qu'un thread peut traiter
	if(fmod(total_lignes, PLAGE) != 0) nb_thread++; //vérification qu'il ne reste pas des valeurs à traiter, si oui on rajoute un thread
	fichier = malloc(sizeof(float)*total_lignes);
	retour = malloc(sizeof(float)*nb_thread);
	thread = malloc(sizeof(ATTR)*nb_thread);
	
			/// Remplissage du tableau avec les valeurs contenues dans le fichier ///
	remplissage_tableau(fichier, fd, total_lignes, &position_deb);
	
			/// Initialisation et création des threads ///
	init_creation_threads(thread, fichier, nb_thread, total_lignes, fonction);
	
			/// Obtention des réponses ///
	/* Ici on remplit le tableau retour avec les retour des threads */
	for(i=0; i<nb_thread; i++){
		pthread_join(thread[i].th, NULL);
		retour[i] = thread[i].retour;
	}
	
			/// Recherche de la réponse finale ///
	if(nb_thread == 1){ //s'il n'y a qu'un seul thread, on peut renvoyer tout de suite la réponse
		close(fd);
		free(thread);
		free(fichier);
		free(retour);
		return thread[0].retour;
	}
	
	if(fonction == odd){
		float rep = odd_tab(nb_thread, retour);
		close(fd);
		free(thread);
		free(fichier);
		free(retour);
		return rep;
	}
	
	/* S'il y a plusieurs thread, on créer un dernier thread qui va s'occuper d'effectuer une dernière fois
	 * l'opération demandée mais sur l'ensemble des réponses données par les threads, soit sur le tableau retour */
	float rep; //pour le retour de la fonction reponse 
	rep = reponse(retour, fonction, nb_thread);
	
	close(fd);
	free(thread);
	free(fichier);
	free(retour);
	
	return rep;
}
